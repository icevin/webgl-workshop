<script type='module'>
    /*  https://threejsfundamentals.org/threejs/lessons/threejs-fundamentals.html */
    /** https://threejs.org/docs/#api/en/lights/shadows/DirectionalLightShadow
     *  https://threejsfundamentals.org/threejs/lessons/threejs-shadows.html 
     *  https://github.com/mrdoob/three.js/blob/master/examples/webgl_postprocessing_ssao.html
     * */
    
    import * as THREE from 'https://unpkg.com/three/build/three.module.js';
    import { EffectComposer } from 'https://unpkg.com/three/examples/jsm/postprocessing/EffectComposer.js';
    import { SSAOPass } from 'https://unpkg.com/three/examples/jsm/postprocessing/SSAOPass.js';

    var canvas  = null;
    var renderer = null;
    var camera = null;
    var scene = null;
    var composer = null;

    var obj = {};
    var scale = 1;

    window.addEventListener('load', function(){
        canvas = document.querySelector('#canvas');
        renderer = new THREE.WebGLRenderer({canvas});
        renderer.shadowMap.enabled = true;

        scene = new THREE.Scene();
        scene.background = new THREE.Color('white');
        
        camera = new THREE.OrthographicCamera( -0.5, 0.5, 0.5, -0.5, 0, 1000);
        camera.zoom = 0.1;
        camera.updateProjectionMatrix();

        let width = document.documentElement.clientWidth;
        let height = 650;

        composer = new EffectComposer( renderer );

        const ssaoPass = new SSAOPass( scene, camera, width, height );
        ssaoPass.kernelRadius = 32;
        composer.addPass( ssaoPass );

        const plane_geometry = new THREE.PlaneGeometry( 40, 40, 40, 40);  
        const geometry = new THREE.BoxGeometry(1, 1, 2);

        const material = new THREE.MeshLambertMaterial({color: 0xE0E0E0});  // greenish blue
        const material_1 = new THREE.MeshLambertMaterial({color: 0xFFFFFF});  // greenish blue

        obj.cube = new THREE.Mesh(geometry, material);
        obj.cube.castShadow = true;
        obj.cube.receiveShadow = true;
        scene.add(obj.cube);

        obj.ground = new THREE.Mesh(plane_geometry, material_1);
        obj.ground.rotation.x = -3.14/2;
        obj.ground.position.x = 0;
        obj.ground.position.z = 0;
        obj.ground.receiveShadow = true;
        scene.add(obj.ground);

        {
            const color = 0xFFFFFF;
            const intensity = 0.9;
            const light = new THREE.DirectionalLight(color, intensity);
            light.position.set(0, 10, 4);
            light.target.position.set(-5, 0, 0);
            light.castShadow = true;
            light.shadow.camera.far = 1000;

            scene.add(light);
            scene.add(light.target);
            
            const helper = new THREE.CameraHelper( light.shadow.camera );
            scene.add( helper );
        }

        {
            const groundColor = 0xCCCCFF; 
            const intensity = 0.4;
            const light = new THREE.AmbientLight(groundColor, intensity);
            scene.add(light);
        }
        resize_canvas();
        requestAnimationFrame(render);
    });

    window.addEventListener('resize', e=>{
        resize_canvas();
    });

    function render(time) {
        time *= 0.001;  

        obj.cube.rotation.y = time;
        obj.cube.position.y = 0.5;

        camera.position.set(0,4,6);
        camera.lookAt(0,0,0);

        renderer.render(scene, camera);
        //composer.render(scene, camera);


        requestAnimationFrame(render);
    }

    function resize_canvas(){

        // Get display scaling
        scale = window.devicePixelRatio;
        console.log(scale);
        // Set canvas resolution
        let width = document.documentElement.clientWidth;
        let height = 650;
        canvas.width = width * scale;
        canvas.height = height * scale;
       
        renderer.setSize(canvas.width, canvas.height)
        composer.setSize(canvas.width, canvas.height)
        
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';

        let aspect = width / height;
        camera.top = 0.5 / aspect;
        camera.bottom = -0.5 / aspect;
        camera.updateProjectionMatrix();
        
    }

</script>
<style>
    body{
        margin: 0;
    }
</style>
<body>
    <canvas id="canvas">

    </canvas>
</body>